OpenSSL Commands
################
   # We will simulate users with User1 & User2
   # User1 will sign a file and send it to User2

   # Steps:
   # We will create a file
   # We will get a hash for the file
   # We will create an encrypted hash. (This is the signature)
   # We send file and signature to receiver
   # We send the users public key
   # Receiver can decrypt and very the signature

Signing a Document
##################

This can all be packaged in a script file to automate:
1. Create a private key for User1
   $ openssl genrsa -out user1_private_key.pem 2048
      # Creates the private key
      # Does not require a password

2. Extract the public key, from the private key
   $ openssl rsa -in user1_private_key.pem -outform PEM -pubout -out user1_public_key.pem

3. Create the file to sign
   $ echo 'Hello, OpenSSL is cool!' > message_user1.txt

4. Create a hash for the file
   $ openssl dgst -sha256 message_user1.txt > message_user1.txt.sha256

5a.Create encrypted hash for the file
   $ openssl rsautl -sign -inkey user1_private_key.pem -keyform PEM -in message_user1.txt.sha256 -out message_user1.txt.sha256.sign-a

5b.Create encrypted hash for the file
   $ openssl dgst -sha256 -sign user1_private_key.pem -out message.txt.sha256.sign-b message_user1.txt
      # An alternative method

# Send the information to User 2
   # Signature file
   # Private key 
   # File 

   $ cp message_user1.txt ../User2_Signature
   $ cp user1_public_key.pem ../User2_Signature
   $ cp message_user1.txt.sha256.sign-a ../User2_Signature

Verify the singed document
##########################

6. Unencrypt the hash for the file
   $ openssl rsautl -verify -inkey user1_public_key.pem -pubin -keyform PEM -in message_user1.txt.sha256.sign-a > hash_from_signature.txt

7. Generate the hash for the file
   $ sha256sum message_user1.txt // Linux
   $ openssl dgst -sha256 message_user1.txt // Mac alternative

8. Compare the hash for the file with the unencrypted hash
      # Option a: Manually
      # Option b: $ sha256sum -c hash_from_signature.txt // Linux
      # Option c: $ shasum -a 256 -c hash_from_signature.txt // Mac

9. Unencrypt and compare in one step (for 5b)
   $ openssl dgst -sha256 -verify user1_public_key.pem -signature message.txt.sha256.sign-b message_user1.txt
      # Will get: Verified Ok is hashes match
      # Will get:  Verification Failure if hashes are different

# similar to previous video.
# We wil use openssl digest to create a signature directly
# from user1 folder:
 $ openssl dgst -sha256 -sign user1_private_key.pem -out message.txt.sha256.sign-b message_user1.txt










Questions
   How do you know the senders public key is in fact his key and not a new key, generated by someone else

   Last time we encrypted with a public key and this time we decrypted with a public key. Â¿can you always do both?